import{r,R as d}from"./app-9sOlul-A.js";import{e as m}from"./index-BaUHjtOz.js";var E=d[" useId ".trim().toString()]||(()=>{}),I=0;function C(t){const[o,e]=r.useState(E());return m(()=>{e(l=>l??String(I++))},[t]),o?`radix-${o}`:""}var R=d[" useInsertionEffect ".trim().toString()]||m;function P({prop:t,defaultProp:o,onChange:e=()=>{},caller:l}){const[i,n,s]=w({defaultProp:o,onChange:e}),c=t!==void 0,v=c?t:i;{const u=r.useRef(t!==void 0);r.useEffect(()=>{const f=u.current;f!==c&&console.warn(`${l} is changing from ${f?"controlled":"uncontrolled"} to ${c?"controlled":"uncontrolled"}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`),u.current=c},[c,l])}const S=r.useCallback(u=>{var f;if(c){const a=$(u)?u(t):u;a!==t&&((f=s.current)==null||f.call(s,a))}else n(u)},[c,t,n,s]);return[v,S]}function w({defaultProp:t,onChange:o}){const[e,l]=r.useState(t),i=r.useRef(e),n=r.useRef(o);return R(()=>{n.current=o},[o]),r.useEffect(()=>{var s;i.current!==e&&((s=n.current)==null||s.call(n,e),i.current=e)},[e,i]),[e,l,n]}function $(t){return typeof t=="function"}export{P as a,C as u};
