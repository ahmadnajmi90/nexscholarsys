import{r,t as a}from"./app-BfGWvB7w.js";import{b as m}from"./index-ateNRHzS.js";var E=a[" useId ".trim().toString()]||(()=>{}),I=0;function C(t){const[e,o]=r.useState(E());return m(()=>{o(l=>l??String(I++))},[t]),e?`radix-${e}`:""}var b=a[" useInsertionEffect ".trim().toString()]||m;function P({prop:t,defaultProp:e,onChange:o=()=>{},caller:l}){const[i,n,s]=w({defaultProp:e,onChange:o}),c=t!==void 0,v=c?t:i;{const u=r.useRef(t!==void 0);r.useEffect(()=>{const f=u.current;f!==c&&console.warn(`${l} is changing from ${f?"controlled":"uncontrolled"} to ${c?"controlled":"uncontrolled"}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`),u.current=c},[c,l])}const S=r.useCallback(u=>{var f;if(c){const d=R(u)?u(t):u;d!==t&&((f=s.current)==null||f.call(s,d))}else n(u)},[c,t,n,s]);return[v,S]}function w({defaultProp:t,onChange:e}){const[o,l]=r.useState(t),i=r.useRef(o),n=r.useRef(e);return b(()=>{n.current=e},[e]),r.useEffect(()=>{var s;i.current!==o&&((s=n.current)==null||s.call(n,o),i.current=o)},[o,i]),[o,l,n]}function R(t){return typeof t=="function"}export{P as a,C as u};
