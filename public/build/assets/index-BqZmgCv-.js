import{r,t as d}from"./app-DJY3TfTO.js";import{b as v}from"./index-Bg3vYy3P.js";var E=d[" useId ".trim().toString()]||(()=>{}),b=0;function C(t){const[e,o]=r.useState(E());return v(()=>{t||o(l=>l??String(b++))},[t]),t||(e?`radix-${e}`:"")}var w=d[" useInsertionEffect ".trim().toString()]||v;function P({prop:t,defaultProp:e,onChange:o=()=>{},caller:l}){const[f,n,s]=I({defaultProp:e,onChange:o}),c=t!==void 0,m=c?t:f;{const u=r.useRef(t!==void 0);r.useEffect(()=>{const i=u.current;i!==c&&console.warn(`${l} is changing from ${i?"controlled":"uncontrolled"} to ${c?"controlled":"uncontrolled"}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`),u.current=c},[c,l])}const S=r.useCallback(u=>{var i;if(c){const a=R(u)?u(t):u;a!==t&&((i=s.current)==null||i.call(s,a))}else n(u)},[c,t,n,s]);return[m,S]}function I({defaultProp:t,onChange:e}){const[o,l]=r.useState(t),f=r.useRef(o),n=r.useRef(e);return w(()=>{n.current=e},[e]),r.useEffect(()=>{var s;f.current!==o&&((s=n.current)==null||s.call(n,o),f.current=o)},[o,f]),[o,l,n]}function R(t){return typeof t=="function"}export{P as a,C as u};
