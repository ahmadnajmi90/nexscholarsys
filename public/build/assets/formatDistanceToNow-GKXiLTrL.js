import{c as y}from"./constructNow-DtVD-0hX.js";import{t as l,n as S,e as O,a as X,d as I,f as D,g as _}from"./en-US-DNUEYIb-.js";function M(r,t){const e=+l(r)-+l(t);return e<0?-1:e>0?1:e}function T(r,t,e){const[s,n]=S(e==null?void 0:e.in,r,t),u=s.getFullYear()-n.getFullYear(),c=s.getMonth()-n.getMonth();return u*12+c}function Y(r){return t=>{const s=(r?Math[r]:Math.trunc)(t);return s===0?0:s}}function b(r,t){return+l(r)-+l(t)}function w(r,t){const e=l(r,t==null?void 0:t.in);return e.setHours(23,59,59,999),e}function F(r,t){const e=l(r,t==null?void 0:t.in),s=e.getMonth();return e.setFullYear(e.getFullYear(),s+1,0),e.setHours(23,59,59,999),e}function N(r,t){const e=l(r,t==null?void 0:t.in);return+w(e,t)==+F(e,t)}function H(r,t,e){const[s,n,u]=S(e==null?void 0:e.in,r,r,t),c=M(n,u),a=Math.abs(T(n,u));if(a<1)return 0;n.getMonth()===1&&n.getDate()>27&&n.setDate(30),n.setMonth(n.getMonth()-c*a);let o=M(n,u)===-c;N(s)&&a===1&&M(s,u)===1&&(o=!1);const d=c*(a-+o);return d===0?0:d}function v(r,t,e){const s=b(r,t)/1e3;return Y(e==null?void 0:e.roundingMethod)(s)}function z(r,t,e){const s=_(),n=(e==null?void 0:e.locale)??s.locale??O,u=2520,c=M(r,t);if(isNaN(c))throw new RangeError("Invalid time value");const a=Object.assign({},e,{addSuffix:e==null?void 0:e.addSuffix,comparison:c}),[o,d]=S(e==null?void 0:e.in,...c>0?[t,r]:[r,t]),m=v(d,o),x=(X(d)-X(o))/1e3,f=Math.round((m-x)/60);let h;if(f<2)return e!=null&&e.includeSeconds?m<5?n.formatDistance("lessThanXSeconds",5,a):m<10?n.formatDistance("lessThanXSeconds",10,a):m<20?n.formatDistance("lessThanXSeconds",20,a):m<40?n.formatDistance("halfAMinute",0,a):m<60?n.formatDistance("lessThanXMinutes",1,a):n.formatDistance("xMinutes",1,a):f===0?n.formatDistance("lessThanXMinutes",1,a):n.formatDistance("xMinutes",f,a);if(f<45)return n.formatDistance("xMinutes",f,a);if(f<90)return n.formatDistance("aboutXHours",1,a);if(f<I){const i=Math.round(f/60);return n.formatDistance("aboutXHours",i,a)}else{if(f<u)return n.formatDistance("xDays",1,a);if(f<D){const i=Math.round(f/I);return n.formatDistance("xDays",i,a)}else if(f<D*2)return h=Math.round(f/D),n.formatDistance("aboutXMonths",h,a)}if(h=H(d,o),h<12){const i=Math.round(f/D);return n.formatDistance("xMonths",i,a)}else{const i=h%12,g=Math.trunc(h/12);return i<3?n.formatDistance("aboutXYears",g,a):i<9?n.formatDistance("overXYears",g,a):n.formatDistance("almostXYears",g+1,a)}}function R(r,t){return z(r,y(r),t)}export{R as f};
